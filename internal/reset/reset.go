package reset

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"io/fs"
	"os"
	"path/filepath"
	"slices"
	"strings"
	"text/template"
)

type ResetParam struct {
	FieldName       string
	FieldType       string
	PointerFlag     bool
	ChildStructFlag bool
	ArrayFlag       bool
	MapFlag         bool
	ResetAction     string
}

type ResetStruct struct {
	Name   string
	Params []ResetParam
}

type ResetPackage struct {
	Package string
	Path    string
	Structs []ResetStruct
}

const FooterTemplate string = `
// Code generated by go generate; DO NOT EDIT.
// This file was generated by genreset.go

package {{.Package}}

`

const ResetTemplate string = `
{{range .Structs}}
func (rs *{{.Name}}) Reset() {
	if rs == nil {
		return
	}
    {{range .Params}}{{if .ResetAction}}{{.ResetAction}}{{end}}{{end}}
}
{{end}}`

var footerTmpl = template.Must(template.New("reset").Parse(FooterTemplate))

var tmpl = template.Must(template.New("reset").Parse(ResetTemplate))

var basicTypesNum = []string{

	"int", "int8", "int16", "int32", "int64",
	"uint", "uint8", "uint16", "uint32", "uint64", "uintptr",

	"byte",
	"rune",

	"float32", "float64",
	"complex64", "complex128",
}

func (p *ResetParam) GenResetAction() {
	if p.MapFlag == true {
		p.ResetAction = fmt.Sprintf("clear(rs.%s)\n", p.FieldName)
	}
	if p.ArrayFlag == true {
		p.ResetAction = fmt.Sprintf("rs.%s = rs.%s[:0]\n", p.FieldName, p.FieldName)
		return
	}
	if p.ChildStructFlag == true {
		p.ResetAction = fmt.Sprintf(`var rsInterface interface{} = %s{}
	if resetter, ok := rsInterface.(interface{ Reset() }); ok && rs.%s != nil {
		resetter.Reset()
	}`, strings.TrimPrefix(p.FieldType, "*"), p.FieldName)
		return
	}
	if p.FieldType == "bool" {
		p.ResetAction = fmt.Sprintf("rs.%s = false\n", p.FieldName)
		return
	}
	if p.FieldType == "*bool" {
		p.ResetAction = fmt.Sprintf(`if rs.%s != nil {
				*rs.%s = false}
				`, p.FieldName, p.FieldName)
		return
	}
	if p.FieldType == "string" {
		p.ResetAction = fmt.Sprintf("rs.%s = \"\"\n", p.FieldName)
		return
	}
	if p.FieldType == "*string" {
		p.ResetAction = fmt.Sprintf(`if rs.%s != nil {
				*rs.%s = ""}
				`, p.FieldName, p.FieldName)
		return
	}
	if slices.Contains(basicTypesNum, p.FieldType) {
		p.ResetAction = fmt.Sprintf("rs.%s = 0\n", p.FieldName)
		return
	}
	if p.PointerFlag {
		typeValue := strings.TrimPrefix(p.FieldType, "*")
		if slices.Contains(basicTypesNum, typeValue) {
			p.ResetAction = fmt.Sprintf(`if rs.%s != nil {
				*rs.%s = 0}
				`, p.FieldName, p.FieldName)
		}
		return
	}
	return
}
func ParseGen(projectDir string) error {
	// сохраняем директории, в которых уже создан reset.gen.go
	// чтобы при создании Reset метода не в первом файле пакета
	// файл reset.gen.go не перезаписывался, а дополнялся
	dirs := make(map[string]string)

	subDirToSkip := "skip"
	err := filepath.Walk(projectDir, func(path string, info fs.FileInfo, err error) error {
		if err != nil {
			fmt.Printf("prevent panic by handling failure accessing a path %q: %v\n", path, err)
			return err
		}
		if info.IsDir() && info.Name() == subDirToSkip {
			fmt.Printf("skipping a dir without errors: %+v \n", info.Name())
			return filepath.SkipDir
		}

		if !info.IsDir() && strings.HasSuffix(path, ".go") {
			rp := GenerateReset(path)
			if rp != nil {
				dir, _ := filepath.Split(path)
				_, fileExists := dirs[dir]
				if err := rp.RenderTemplate(dir, fileExists); err != nil {
					fmt.Println("unable to render generated file:", err)
				}
				dirs[dir] = ""
			}
		}

		// fmt.Printf("visited file or dir: %q\n", path)
		return nil
	})
	if err != nil {
		return err
	}
	return nil
}

func (rp *ResetPackage) RenderTemplate(dir string, FileExistsFlag bool) error {
	var buf bytes.Buffer
	var footerBuf bytes.Buffer
	var footerBufFmt []byte

	err := footerTmpl.Execute(&footerBuf, rp)
	if err != nil {
		return err
	}

	err = tmpl.Execute(&buf, rp)
	if err != nil {
		return err
	}

	if !FileExistsFlag {
		footerBufFmt, err = format.Source(footerBuf.Bytes())
		if err != nil {
			panic(err)
		}
	}

	// fmt.Print(string(buf.Bytes()))

	bufFmt, err := format.Source(buf.Bytes())
	if err != nil {
		panic(err)
	}

	if !FileExistsFlag {
		file, err := os.OpenFile(fmt.Sprint(dir, "/reset.gen.go"), os.O_WRONLY|os.O_TRUNC|os.O_CREATE, 0666)
		if err != nil {
			fmt.Println("unable to open file to write", err)
			return err
		}

		_, err = file.Write(footerBufFmt)
		if err != nil {
			fmt.Println("unable to append footer code to file", err)
			return err
		}

		_, err = file.Write(bufFmt)
		if err != nil {
			fmt.Println("unable to append generated code to file", err)
			return err
		}

		// err = os.WriteFile(fmt.Sprint(dir, "/reset.gen.go"), bufFmt, 0666)
		// if err != nil {
		// 	fmt.Printf("unable to write file for %s", dir)
		// 	return err
		// }
		fmt.Printf("%sreset.gen.go created\n", dir)
		return nil
	}

	file, err := os.OpenFile(fmt.Sprint(dir, "/reset.gen.go"), os.O_WRONLY|os.O_APPEND, 0666)
	if err != nil {
		fmt.Println("unable to append generated code to file", err)
		return err
	}

	_, err = file.Write(buf.Bytes())
	if err != nil {
		fmt.Println("unable to append generated code to file", err)
		return err
	}

	return nil
}

func GenerateReset(filename string) *ResetPackage {

	fset := token.NewFileSet()
	f, err := parser.ParseFile(fset, filename, nil, parser.ParseComments)
	if err != nil {
		// fmt.Printf("Failed to parse file %v\n", f)
		return nil
	}

	pathSlice := strings.Split(filename, "/")
	path := strings.Join(pathSlice[:(len(pathSlice)-1)], "/")

	packStructs := ResetPackage{
		Package: f.Name.Name,
		Path:    path,
	}

	if strings.HasSuffix(filename, ".go") {
		for _, d := range f.Decls {
			var gd *ast.GenDecl
			var ok bool
			if gd, ok = d.(*ast.GenDecl); !ok {
				continue
			}

			if gd.Doc != nil {
				if gd.Doc.List != nil {
					for _, c := range gd.Doc.List {
						if strings.HasPrefix(c.Text, "// generate:reset") {
							// fmt.Println(fset.Position(c.Slash).String(), c.Text)

							sp := ResetStruct{}
							structParams := []ResetParam{}

							for _, s := range gd.Specs {
								if ts, ok := s.(*ast.TypeSpec); ok {
									sp.Name = ts.Name.Name
									if st, ok := ts.Type.(*ast.StructType); ok {
										structParams = make([]ResetParam, 0, len(st.Fields.List)) // делаем чтобы не переалоцировать память при аппендах
										for _, field := range st.Fields.List {
											if len(field.Names) < 1 {
												continue
											}

											fieldName := field.Names[0].Name // не пойму, почему не всегда нужно выполнять приведение типов
											structP := ResetParam{
												FieldName: fieldName,
											}

											// логика для обычных типов
											if i, ok := field.Type.(*ast.Ident); ok {
												structP.FieldType = i.Name
											}

											// логика для мапов
											if m, ok := field.Type.(*ast.MapType); ok {
												structP.FieldType = fmt.Sprintf("map[%s]%s", m.Key, m.Value)
												structP.MapFlag = true
											}

											// логика для массивов
											if a, ok := field.Type.(*ast.ArrayType); ok {
												if i, ok := a.Elt.(*ast.Ident); ok {
													structP.FieldType = "[]" + i.Name
													structP.ArrayFlag = true
												}
											}

											// логика для указателей
											if se, ok := field.Type.(*ast.StarExpr); ok {
												if i, ok := se.X.(*ast.Ident); ok {
													structP.FieldType = "*" + i.Name
													structP.PointerFlag = true
													if i.Obj != nil {
														structP.ChildStructFlag = true
													}
												}
											}

											structP.GenResetAction()
											if err != nil {
												fmt.Println("unable to generate reset action")
											}

											structParams = append(structParams, structP)

											sp.Params = structParams
										}
									}
								}
							}
							if sp.Params == nil {
								fmt.Println("incorrect struct", sp.Name)
								continue
							}
							packStructs.Structs = append(packStructs.Structs, sp)
						}

					}

				}

			}

			// if err = ast.Print(fset, d); err != nil {
			// 	fmt.Println("unable to print the ast tree")
			// }
		}
	}
	if packStructs.Structs == nil {
		return nil
	}

	// fmt.Print(packStructs)

	return &packStructs
}
