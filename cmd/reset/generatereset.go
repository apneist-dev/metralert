package main

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"io/fs"
	"os"
	"path/filepath"
	"slices"
	"strings"
	"text/template"
)

type ResetParam struct {
	FieldName       string
	FieldType       string
	PointerFlag     bool
	ChildStructFlag bool
	ResetAction     string
}

type ResetStruct struct {
	Name   string
	Params []ResetParam
}

type ResetPackage struct {
	Package string
	Path    string
	Structs []ResetStruct
}

const ResetTemplate string = `
// Code generated by go generate; DO NOT EDIT.
// This file was generated by genreset.go

package {{.Package}}

{{range .Structs}}
func (s *{{.Name}}) Reset() {
	if s == nil {
		return
	}
    {{range .Params}}{{if .ResetAction}}{{.ResetAction}}{{end}}{{end}}
}
{{end}}
`

var tmpl = template.Must(template.New("reset").Parse(ResetTemplate))

var basicTypesNum = []string{

	"int", "int8", "int16", "int32", "int64",
	"uint", "uint8", "uint16", "uint32", "uint64", "uintptr",

	"byte", // alias for uint8
	"rune", // alias for int32

	"float32", "float64",
	"complex64", "complex128",
}

func (p *ResetParam) GenResetAction() error {
	if p.FieldType == "bool" {
		p.ResetAction = fmt.Sprintf("s.%s = false\n", p.FieldName)
	}
	if p.FieldType == "*bool" {
		p.ResetAction = fmt.Sprintf(`if s.%s != nil {
				*s.%s = false}
				`, p.FieldName, p.FieldName)
	}
	if p.FieldType == "string" {
		p.ResetAction = fmt.Sprintf("s.%s = \"\"\n", p.FieldName)
	}
	if p.FieldType == "*string" {
		p.ResetAction = fmt.Sprintf(`if s.%s != nil {
				*s.%s = ""}
				`, p.FieldName, p.FieldName)
	}

	if slices.Contains(basicTypesNum, p.FieldType) {
		p.ResetAction = fmt.Sprintf("s.%s = 0\n", p.FieldName)
	}
	if p.PointerFlag {
		typeValue := strings.TrimPrefix(p.FieldType, "*")
		if slices.Contains(basicTypesNum, typeValue) {
			p.ResetAction = fmt.Sprintf(`if s.%s != nil {
				*s.%s = 0}
				`, p.FieldName, p.FieldName)
		}
	}
	return nil
}

func main() {
	tmpDir := "../../"
	subDirToSkip := "skip"
	err := filepath.Walk(".", func(path string, info fs.FileInfo, err error) error {
		if err != nil {
			fmt.Printf("prevent panic by handling failure accessing a path %q: %v\n", path, err)
			return err
		}
		if info.IsDir() && info.Name() == subDirToSkip {
			fmt.Printf("skipping a dir without errors: %+v \n", info.Name())
			return filepath.SkipDir
		}

		if !info.IsDir() && strings.HasSuffix(path, ".go") {
			Generatereset(path)
		}

		// fmt.Printf("visited file or dir: %q\n", path)
		return nil
	})
	if err != nil {
		fmt.Printf("error walking the path %q: %v\n", tmpDir, err)
		return
	}
}

func Generatereset(filename string) {

	fset := token.NewFileSet()
	f, err := parser.ParseFile(fset, filename, nil, parser.ParseComments)
	if err != nil {
		// fmt.Printf("Failed to parse file %v\n", f)
		return
	}

	pathSlice := strings.Split(filename, "/")
	path := strings.Join(pathSlice[:(len(pathSlice)-1)], "/")

	packStructs := ResetPackage{
		Package: f.Name.Name,
		Path:    path,
	}

	if strings.HasSuffix(filename, "metrics.go") {
		for _, d := range f.Decls {
			var gd *ast.GenDecl
			var ok bool
			if gd, ok = d.(*ast.GenDecl); !ok {
				continue
			}

			if gd.Doc != nil {
				if gd.Doc.List != nil {
					for _, c := range gd.Doc.List {
						if strings.HasPrefix(c.Text, "// generate:reset") {
							fmt.Println(fset.Position(c.Slash).String(), c.Text)

							sp := ResetStruct{}
							structParams := []ResetParam{}

							for _, s := range gd.Specs {
								if ts, ok := s.(*ast.TypeSpec); ok {
									sp.Name = ts.Name.Name
									if st, ok := ts.Type.(*ast.StructType); ok {
										structParams = make([]ResetParam, 0, len(st.Fields.List)) // делаем чтобы не переалоцировать память при аппендах
										for _, field := range st.Fields.List {
											if len(field.Names) < 1 {
												continue
											}

											fieldName := field.Names[0].Name // не пойму, почему не всегда нужно выполнять приведение типов
											structP := ResetParam{
												FieldName: fieldName,
											}

											// логика для обычных типов
											if i, ok := field.Type.(*ast.Ident); ok {
												structP.FieldType = i.Name
											}
											// логика для указателей
											if se, ok := field.Type.(*ast.StarExpr); ok {
												if i, ok := se.X.(*ast.Ident); ok {
													structP.FieldType = "*" + i.Name
													structP.PointerFlag = true
												}
											}

											err = structP.GenResetAction()
											if err != nil {
												fmt.Println("unable to generate reset action")
											}

											structParams = append(structParams, structP)

											sp.Params = structParams
										}
									}
								}
							}
							if sp.Params == nil {
								fmt.Println("incorrect struct", sp.Name)
								continue
							}
							packStructs.Structs = append(packStructs.Structs, sp)
						}

					}

				}

			}

			// if err = ast.Print(fset, d); err != nil {
			// 	fmt.Println("unable to print the ast tree")
			// }
		}
	}
	if packStructs.Structs == nil {
		return
	}

	fmt.Print(packStructs)

	var buf bytes.Buffer
	err = tmpl.Execute(&buf, packStructs)
	if err != nil {
		panic(err)
	}

	fmt.Print(string(buf.Bytes()))

	bufFmt, err := format.Source(buf.Bytes())
	if err != nil {
		panic(err)
	}

	err = os.WriteFile(fmt.Sprint(path, "/reset.gen.go"), bufFmt, 0666)
	fmt.Println(path, "/reset.gen.go created")
}
